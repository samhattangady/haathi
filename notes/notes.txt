23 Jun 2023:
Today is the first day of the project. Mostly it will end up setting up a
bunch of things. I don't really have much of an engine in place, so I think
the main focus for the day would be to set that up.

So I want to have the following things, all running in browser.
- Draw textured triangles (this will cover fonts as well) across user defined
  layers.
- Recieve mouse and keyboard inputs.
- Load files, and write to html5memory.
- Play sounds.

I have done some of these things before, with the KCPS port, but this time I
want it to be a little cleaner. I think instead of using webgl, I would like
to use web canvas, and see how that works. I don't know how well that would
deal with textured triangles and things, but it might be the simplest way to
get things started.

So going through the Canvas API, it seems that it has some pretty good support
for shapes and things, which we should take full advantage of. Eventually we
might want to target other platforms as well, but that is all a problem for
later. For now, we should just focus on making the best / simplest API across
zig and WASM.

I also want to keep some of the things that we learned from dragonruby. We
always want the final canvas to be of 1280x720. If the screen is larger or
smaller, let the renderer handle the scaling and things. For the sake of the
engine itself, it always considers that resolution, and so it can use that in
all the cases where it is necessary.

Step 1:
Set up a basic app, where we are drawing a square to the canvas. When space is
held down, the square changes to one colour. When mouse is held down, it
changes to another color. That's all. And also set up the build and things to
make it easy to run.

I think the focus should be on just working on this project for now. Forget
about the engine overall. We can slowly factor out the things that need to be
common. For now we should be fine just as is.

I am having some problems with WASM. When I import the wasm file, it doesn't
seem to have the functions that were exported from zig. This needs to be
fixed.

It seems like it was some issue with the build options, which has been changed
since all the public examples were posted...

---

The supported behaviour for inputs in web is that they pass a string with the
name of the key. That's not ideal to pass back into zig. So we probably should
be convert to a number in js itself? But it will be important to make sure
that the two are kept in sync.

---

Cool, now we have all the basic things passing through easily. That initial
POC stuff is done. I think we can stop here for today.
The next thing to work on would be to figure out where the game code goes, and
how much should go into main. Ideally, it should be as low as possible, but I
guess that's not fully in our hands. But lets try =).

---

26 Jun 2023:
So this week we have some work to get done on the jam. Some other time
commitments also. So let's just see how it all turns out. I think that we can
either start off on the game, or do some more amount of organisation. Though
actually I think those both are the same.

So lets just start off and see where it takes us I guess.
Okay, it seems like we now have the basic scaffolding mostly set up. So now
its just time to start implementing the rest of the things.

So lets draw the target wave first. Let it be a sine wave.

Okay, we have the basic of that thing rendering. Lets commit before we
proceed.

I am interested in trying out a breadboard based design for the wiring up of
the circuit. I think that might be cool. Then we can pick and place components
onto that, and it will do the things. But I think that comes a little bit
later. There is a lot more work that we need to get done with before we can
reach that stage.

The main thing that we need to figure out is how to pass around the data. In
my head it feels like that it is similar to a node-based programming system
like a blender or whatever. So that would probably be the structure as well?

What we want is to support each component having multiple outputs, and a fixed
set of inputs (like min will have to have atleast 2 inputs to even make
sense). I wonder whether that would make the breadboard idea better or
worse...
Also maybe breadboard doesn't make too much sense, because it becomes very
easy to short-circuit I think.

Okay, lets forget all of that for now. We have a much bigger question that
still needs to be answered. How exactly wre we going to be doing the
calculations. Maybe we just take one value, and then pass it down the whole
chain, and come out with another value at the other end. But there will be
branches and guys will have to wait for other branches to complete and things
like that. But we can just do basic depth-first or breadth first, either way
should be fine. Basically keep iterating through all the components until all
of them have been solved.

What is an easy way that we can test this all out though? Especially if we
want something like a frequency modulator? Lets start out with a basic set of
components.

- Source
- ~Double Frequency~ Source with 2x frequency.
- Half Amplitude
- Min

For example, if someone decides to put a frequency modulator at a later stage,
then I don't even know what the best way of thinking of that would even be.
Because at that point, we are trying to literally look forward/backward in
time. So maybe frequency modulation should not be allowed.

Yeah okay. I think that makes some modicum of sense. Maybe we can also just
allow rightwards connections? That also should be a decent thing.

Damn. Its a little complicated to figure out the smallest part of this to
build. But yeah, that's now pushed to tomorrow. Decent progress overall I
guess.

---

27 Jun 2023:
Bit late start to the day today. But lets see what we can accomplish =)
I think we need to just get some basic things up and working even if it does
not have in game interactivity.
Okay, now we need tofigure out exactly how the information will be travelling
thorugh the "wires".

Nice. We have a basic version running, and it looks good. Quite simple to code
out overall, though ofcourse, setting up the things in code obviously makes it
all a bit easier.

---

28 Jun 2023:
We got the basic things up. Now we need to add some kind of interface that we
can interact with. Okay then.
We also need to figure out exactly what is the interface that we want to build
for the thing.
Also game name idea: sine cosine desine

Back to the interface though for now. We had some ideas I think. The main
thing that we need to accomplish is to make sure that there is nothing that is
being connected backwards.

That was quite a bit that we got done today.
I think tomorrow we have to clean up creating and deleting connections. We
were concerned that there was no way to delete a connection on an undeletable
component, but there is no reason why a right click couldn't just remove all
its connections...


---

29 Jun 2023:
Okay what is the first thing that awe can work on today? It's either
converting the connections to the component tree. Or some more controls.

---

30 Jun 2023:
So we have the _toy_ ready. Today we need to make it into a game.

---

10 Jul 2023:
Working on hiveminder. We have the basic hex grid ready. Now we have to ask
the question, what is the experience of a city builder that we are looking to
distill? What is it about the genre that we think should be captured. Forget
all the other things that you know a bout games right now. Just focus on that
base.

Growth is definitely one. The feeling of accomplishment over watching the
thing grow.
Balance of resources. You need population to fill jobs. But houses require
maintenance. More houses means that a large part of the new population will go
towards maintenance rather than industry.

What are the decisions that you take? And what are the decisions that are out
of your hands?
- What to build where. In the case of a beehive, the plots are all already
  fixed. All you just decide what needs to be built.

What are the resources that we are balancing?
- Population
- Food
- Jobs

What are the jobs?
- Food / honey collection
- Builders
- Looking after youngers

What are the rooms?
- Queen
- Queen minders / look after youngers
- Food Collectors
- Builders
- Maintainers
- Storage
- Sleep
- Incubate

What are the other mechanics
- exhaustion - if bees are working too much, their exhaustion will rise so
  you need to have enough bees in all the workstations
  If there is too much exhaustion, then the bees will revolt/die (and for now,
  you lose)
- Hunger - If there isn't enough honey, bees will eventually die

I think that's enough to get started? I mean, it's honestly too much to get
started, but we still, at some point do need to get started.

What's the first step, what do we need to build first? Damn, that's hard to
figure.

So let's start off with having a simulated working hive. One queen at the
center, one of each room around. And then figure out. Okay. Okay. Okay.

Where do the bees sleep?

Okay, so the way that each bee works:
- request job
- if available: perform job for JOB_LENGTH time
- request food (consume if available)
- request rest (

The way jobs work:
Each job requires a room. That room has a fixed number of slots. When a bee
requests job, if any jobroom has on opening, the bee will get assigned to that
job. Based on the job, some stats of the hive will be modified.

Food:
Every FOOD_DISTRIB cycle, food is equally distributed amongst all bees up to
MAX_FOOD per bee. So if there is not enough total food, each bee will get
equal amount. (Will this lead to a mass death at one point?)
Or we will give MIN_FOOD to each bee based on need until food runs out.

Rest:
If there is a job to be done, bees will do it. If there is none, they will
rest.
(How to balance this so that overworked bees are not at the head of the queue
for jobs?)

So doing a job leads to bee.rest-- and resting leads to bee.rest++
Over time, bee.health--. When they eat, bee.health++

---

11 Jul 2023:
I think that we had stopped in the middle of doing something yesterday. So
lets find out what that was and then continue to do that one.

As expected, we are on the toughest part of the thing, and now we have to do
that before we even had the chance to warm up. Okay. Okay.

So how does the Hive.update() method work?
There are three things that need to be done.
We need to check all the rooms if they have any jobs requested, and then add
those to the list.
We need to check all jobs. If they are unassigned, then we need to assign
them. If they are completed, we need to mark them as compete, remove from job
list, notify the room, and mark the bee as free.
We need to check all bees. If they are not working, based on priority system,
we need to feed them, rest them, and then assign them to job.

One big concern that I have right now is how to handle the indexes and things.
A lot of things will be constantly moving around, and being added and removed
from lists all the time. So we need to make sure that we take care of those
indices not going stale.

With jobs, how should it work? Does the job request a bee, or does the bee
request a job. In the sense that who's update function will be taking care of
that? Maybe we can use the jobs, so that if there is a bee free, we know that
it is not doing a job. But the issue is that they wont be able to eat then.

So we probably will have to have more than three sets of iterations.

So let's then lay that out again.
Iterate through all the assigned_jobs - if complete, mark as complete and
update the room.
Iterate through all the bees - if unassigned, give them food.
Iterate through all the rooms - add to job_requests list if available.
Iterate through all the job_requests - assign bees
Iterate through all the bees - if unassigned, give them rest

That might be one way of doing it.
Another way would be to have multiple lists of bees (or a single list with
flag so that we only iterate through the ones we need)
The lists would be - working, eating, resting, waiting, moving

One big question that we may need to answer now is whether we care about
placements of things, and movements of bees. Or whether we just have global
and everything. So the bee does not have to go to the room to start the job.

Honestly, I really want to have the movement / placement matter, though that
might require a lot of optimization work.

I think we should start off with that. It should be easier to remove that
feature by setting speed as infinite or something along those lines that it
would be to add it in later.

So how would the loops work if we have separate lists for bees in different
states?

iter assigned_jobs - if done, move corresponding bees to waiting, and room to
                     free
iter moving bees - if reached, move to corresponding state
iter eating,resting bees - check if they are done - move to waiting
iter waiting bees - if hungry - set moving to eating
                    if jobs available - set moving to job
                    else set moving to rest
iter rooms - if there is slot, add to job_requests
we shouldn't need to iter job_requests - waiting_bees should take care of
that.

Okay, that looks good to me. I think it might be the correct order of loops as
well.
Cool lets do it.
Do we need separate lists for assigned jobs and requests? I think we should be
okay with one list for now. Can split it later if required.

I think the MVP should start off without aging and incubation. Incubation will
require bees carrying honey from storage to the incubator.

How do we store what the job is in the bee? This is for the moving bees.
Ideally it would be a job index. Or maybe if a bee takes up a job, it can hold
all the info about it. It would make the bee struct larger, but it should be
okay I think.
It's getting a little confusing. So there would be jobs like maintenance. So a
bee would be assigned that job. Then that would need to have the bee move to
different cells to fix it. Similarly, when a bee is collecting, it will have
food, then it will have to move to a place to store that.

I think maybe we shouldn't be so focussed on keeping the bee struct tiny.
There might be more value in keeping things neat as an implementation.

So what all does the bee need to know? I think it should keep the job in
itself.
Then there should be "advertisements", where all bees nearby are signalled,
and they can pick up those advertisements, and then go and do that job. For
example, a storage room will advertise that it is free. And a collector bee
can come and store its honey there. Or any room will advertise that it is
damaged, and a maintenance bee will come and look after it. 

I think I need to be thinking buch more in terms of systems here for the
implementation. Like the Sims video. So at any point, a bee will be recieving
ads. Then based on its needs it can go and try to fulfill its needs. So for
example, if a bee is hungry, or it needs to do incubation, it will respond to
storage.food_available ads. Does that make sense?

So then what would the different ads be?
- storage:food_available
- storage:space_available
- rest:slot_available
- room:maintenance_required
- incubator:food_required
- incubator:attention_required
- incubator:egg_required
- queen:attention_required
- queen:egg_available
- room:construction_required
- collection:bee_required

And then maybe a room would respond to that requirement. So if
storage:space_availble signal is heard, then a nearby collection room will
need to add a job requesting a bee to collect and then fill up that space.
So if each ad is responded to only once, then we should be able to make that
work.

So a storage:space_available ad would get converted into a
collection:bee_required. Then a bee would take up that second ad, and set its
own job to collect, with a destination as that storage:space.

Do we need another resource? Wax? For building and maintenance? Maybe later.

Okay, so with this version of things, the job is attached to the bee. And
resting and eating will also be a job. moving and waiting can be bools

So now again, how would the hive.update look like?

iter bees - move if required. see if job is complete.
            if job is complete
                set bee.job to null
                bee.waiting to true
                update room that slot is now open
iter rooms - create ads
iter rooms - consume ads, maybe create more ads
iter bees - consume ads

So if there is a collection job, there is room, destination and target? The
bee should go to the collection room, then go off map, and then come to the
storage room.
Similarly, incubation task will be go to babysitting room, go to storage, go
to incubation room.
I imagine there might be jobs where there are more also. So how to handle
that? We could just have an array there. Is that the goal though? I am just
trying to think if there is another way to do this.

Okay for now it's assumed that there will only be one waypoint. I think we can
just carry that through for now.

---

12 Jul 2023:
We finally got something to see on screen yesterday, and it was the last thing
that we did. So for today, we need to actually get it to work in the way that
we would like. I think the scale of the prototype we have up is correct
thouhg. We need to start off by observing exactly what is happening.

So exactly how should the first few ticks go?
- Storage signal that there is space available
- Collection consume that, and request a bee for collection
- Bee consumes that and goes to collect. When they come back, they should
  update the room to have more food

Okay damn, that's pretty cool. I think we need a slightly more robust system
of knowing when things need to be signalled and cleared etc. For example, when
the collection room consumes a storage_space_available signal, it shouldn't
decrement the live_signal_count because we don't want another signal to be
emitted until it's all done.

Though now that I think about it, that could cause issues, the storage room
should always have 8 live signals. One for each slot. So then we cant just use
live_signal count as a measure. We need to be more specific and have each slot
haveits own lsignal bool.

Also I wonder whether we should be having more data in the room? a union most
likely

eee. This actually works kinda fun to watch. Lets commit.

So the next thing I want is priority systems. Right now the last bee on the
list never gets to eat. Lets fix that.
Okay. That's okay now.
Next is incubator.

Man we really need to clean up the whole slots, signals and all. Atleast I
think so.

---

13 Jul 2023:
By the end of today, we should be able to have the whole thing be interactive,
and then tune all the numbers.

But first, I am not able to figure out why the incbator requiring food is not
able to reduce food from the storage. Lol, that was quick fix. The main issue
when I was investigating it yesterday was that it was reducing it at the wrong
time, ie when the food was delivered, not when it was picked and that was
causing the confusion. Okay, lets see whether we can fix that.

Yup. That's done.

Next I think that along with adding the interactivity, we should also figure
out how to structure the beginning of the game. Ideally just start off with
the queen, rest, and storage. Then build out the rest after that.

I have a feeling there is an issue with the slots. It feels like after some
time, there is food available, but there are still collectors going out.

---

14 Jul 2023:
Final day of the jam. I think things are in place, and we should be able to
finish. First, we want to get all the stats up and visible so that it's easy
to see the things that are there. We also want to implement death by hunger.
So that's another thing that we can work on.

Good place to start.

---

17 Jul 2023:
New week. New jam. I want to do a thinky racing / drifting game this time. So
the first question is how do we even go about that?
One idea that I had is that you control the car through graphs. So you have
bezier curves and you adjust the steering and acceleration/braking over time,
and that allows you to control the car as well.

I t hink that is an interesting idea. But we cant know if it workds until we
build the damn thing.

The real question is how to tune it. Should we start off with a keyboard
controlled car, and then get the controls etc worked out and then transfer
that over to a graph based controller? Or is it better for us to start off
with the graph based controls itself?

That's honestly quite a hard question. I think we should spend some time on
the keyboard based controls, just to see what all is required to make. After
that we can go to drift based, and then tune the game based on that. Okay. Let
us begin.

I'm just thinking a bit about it. I don't know all that much about drifting,
but the again, so does nobody else. So having the drift resemble what arcade
games have makes sense to me. It's not quite neccessary to have things like
counter steer and things like that in my opinion. Just keep it simple, and
let's see how it turns out. I'm also concerned in general whether it will be
interesting or thinky once it's all in place. But honestly the only way to
know that is to actually sit and do it. So stop procrastinating now.

---

18 Jul 2023:
The drifting stuff really didn't plan out. I think, instead, I am going to
make something traffic related. I have an idea where you have these signals,
with cars waiting at them, and then you connect the different signals to each
other without things crashing. Something like that.

So again, we come to that same question. What is the minimum vialble product
version of this prototype? What we need are cars, signals and connections. So
at each "step", an action gets queued. Cool.
The connections can either be at the exit of the lane, or the entrance of the
lane. ie, when the car enters the intersection or when it leaves it.

But once again, mvp. start off with two lanes, two cars, and one connection,
that triggers on car exit.

Good day good day. I think we have an idea that could work. We have the
systems set up. Tomorrow we start off with adding the player interactions and
level editor and stuffs. It shouldn't take too long. And then we have
potentially 2 and a half days to just explore what the system has to offer.
Nice.

---

19 Jul 2023:
So okay, it's a new day. So we need to start off working. I think we have the
tasks for today morning already planned out last night. First, we add the
player interactions, ie, connecting sensors to signals. Then we add some kind
of level editor (and that should include saving and loading however
rudimentart, even something like saving levels in text...)

Also we need to rename triggers to sensors. Let's do that first =D

So what all does dev mode need?
- add / remove cars in lane
- change the destination of the cars
- set the initial signal states.

Nice. Lot of stuff done. Added all the controls, level editor, level save and
load (rudimentary + manual), better collision checks.
For tomorrow, do the uturn collision check. Smooth out paths. Then just level
design things baby.

---

20 Jul 2023:
I am not sure whether it is better to do the hard stuff first or in a bit.
Right now, I think I want to ease into the day, so lets just knock out
something quick and easy, and then get into the harder stuff. So I think we
can start off with smooth progress along the path.

---

21 Jul 2023:
Final day of the jam. Today, I would like to just focus on making levels. The
only other thing that needs to be done is to add some kind of level select,
and maybe the instructions. Beyond that, we have enough to thoroughly explore
the systems. So let's try to get that done =).

---

24 Jul 2023:
It's a new week again. I have an idea for a programming game about juggling.
Let's see how that all plans out =D

Okay. What's the first thing that we build for juggler? What are all the
things that will be required first of all. Lets see if we can get a bit of a
handle on taht one. Then we can see what's next.

Okay, lets just get a basic cascade going. Lets do the programming studds a
little later.

---

25 Jul 2023:
Yeah not too bad yesterday ya. We got the simple 3ball cascade working fine.
Today we should work on the interface and stuff.

I think one question that we need to answer is how to handle catching. In the
sense that we had thought of a system similar to opus mahnum. So the timing is
fully in our control. Right now, as soon as the hand catches a ball, it will
go on to the next strp, and in that case, we can't control the things in the
same way. Though I guess we could just ask it to set an amount of time to be
"ready", and within that time we catch. And once the time runs out, we move to
the next step regardless of whether we have caught anything or not. That
should be good.

Another big question is how to set up the start position and things. But maybe
that can be handled later.

I think the first thing that I want to do is actually the trail...

We need to rethink how we set up the interface. I don't think we should have
one button for throw, and then edit its properties. I think we should set up
everything first, and then add the block into the timeline.

---

26 Jul 2023:
We have a good idea for how to make the programming blocks. Lets get that done
=D
I think it migght need some amount of prepwork. The throw direction stuff is
one, and just the arm positions...

Two hard things now. One is to convert ThrowParams into paths/vectors. Two is
to convert blocks into code and add the extra stuff (waiting, timings etc.)

Lets do the throwparams first.
So I have start and end positions, and height, which is a yoffset. So I need
to draw a parabola between these points. The thing I am worried about is the
timing/spacing, but I think we can handle that with the lerp, and have the
path be equispaced. But if the path is longer, then the lerp would be
different. Or we could just make it simpler, and do trajectory calculations.
I'd have to look those up, but might make everything a little simpler...

Okay, so I have x0 and x1, and I have v1 also I guess. What I need is theta?
Think I got it.

For tomorrow: Convert the blocks to instructions. Also maybe remove catch?

---

27 Jul 2023:
Cool we have the thing to start off working on. So lets just get to it. =)

store hand starting positions, and ball starting positions in juggler. so that
when we reset it all works correctly.

---

28 Jul 2023:
Last day of this jam. But I really like this idea. Would like to see how I can
develop this further.
Anyway, I think that the first thing that we need to work on today should be
the starting positions stuff. And other reset stuff.

---

31 Jul 2023:
New jam today. The theme is everyday things.
I have an idea about phone charging, and remaining in range of phone to always
be ready to hear it ring.
So it would be some kind off puzzle, where you move around the house, but you
must always be in range of the phone (maybe direct line of sight), and you
will also need your phone for certain purposes (like checking recipes /
passwords etc.) and either have to carry the phone places or use other things
to make notes...

I think this is a kind of game that needs to be designed on paper first...
Yeah and I am not particularly in the mood to do something like that right
now. The other things that I can work on potentially is the engine itself. Add
frames and scaling. We also need to add support for drawing sprites and
playing sounds...

Okay lets do the design thing.

---

01 Aug 2023:
lol i did nothing yesterday. No worries. lets start today. what is the thing
though?i like the idea of having a cable. pushing around furniture. I think I
would like to have just one level. not multiple. in most cases, that means
breaking up the level into different parts. Which is something that we can do
I think.

Okay, let's just start off with a grid then? and then see where it goes?

---

07 Aug 2023:
It's a new day and a new jam. I have the idea to make a game about holi.
Basically, the high level concpet is that it is holi, and all the kids have
holiday, but you work at a startup, and your boss has said that you need to
report for work. So your job is to navigate through various alleys and avoid
the kids. Something like a reversed tower defense.
I like the idea that mechanically, the game is some kind of a card builder. So
movement and everything is dictated by that. In all its more of avoidance,
false triggerring, self shielding and things of that nature.
One more thing that I want to add to that is scaling. Over the course of
building a deck, I want there to be a few stratergies and synergies that the
player can pursue. I dont really know what that would be though... Maybe one
built around movement, one around defense, one around hiding, and things along
those lines.
In the ideation and things we need to figure out how the cards would need to
be designed to facilitate that kind of scaling. Cool, but first we need to get
some of the basic things set up I think,

Okay, so then now we have to figure out what is the first thing that we start
off with. Lets make a grid. Pkay, now we set up all the things to make it work
on this system... Now we need to actually start working...

One more question that we need to spend some time thinking about is whether we
want it to be more tower defense style or whether we want it to be more
tactical... Considering that we have just the one controllable character, both
of those things would probably be the same...

Other ideas for cards:
route optimisation - rather than using the full height, you can reduce that by
a few.

Okay, we have the basic stuff of path generation complete. I think we should
also have the movement done. Lets see that.

The thing that we now need to figure out is, what are enemies? How to
implement? ACtually once we break it down to that level, it doesnt sound that
hard, but still feels kinda intimidating...

So each "tower" would have a certain range, and do a certain amount of damage.
I think I like the concept of having different types of damage. Not just
direct HP stuff. Basically, if you have a water balloon, you would want to
deal with it differently than if you had pichkari or hose, or just colors...

Or maybe today would make more sense to sit and ideate some more.

So what are the different kind of defences that we have? We want one spook
based, where we send a dog / something else in first, and the water / color is
wasted. 
Something umbrella based.
I want something mummy based also, that if you spot the kid, you can threaten
to call his mum, and then he gets spooked and doesnt hose you.
Shelter based? where you can take shelter behind some old man or something
like that? But then how would that work? WOuld they always be hanging around
or do we call them or what?

I think at a system level we need to figure out what are the different
orthogonal factors that each tower has that we can exhaust.

turn off the water connection?

All of this is becoming more thinky puzzle, but thats not what we want. we
want something more systems based that scales and allows problems to be solved
in multiple ways. thats the goal.

maybe the movement should not be card based. instead every turn, we move a
fixed distance, and then based on the cards, that can be manipulated. move
more less etc.

We could also flip the whole thing around? And make it actual tower defense?
How would the card system work then?
That actually might work out? Would be a lot more classical, and allow us to
actually try out the card based things, rather than working out all the
avoidance mechanics even though that is far more satisfying narratively and
such.

Maybe tower defense isnt even the best way. Just have like an output of some
sort. Like water balloons created.
After some point it feels like the non-violent thing is just in spirit alone,
and its a cheap reskin, but I think for now atleast, I am okay with something
like that...

Can we move away from the holi theme as well then?

Or should we just go aehad with ten pin phalanx? That might be a better thing
to go ahead with.

---

08 Aug 2023:
I think it was supposed to be called phalanx pin bowling. but lets go. The
main idea here is a balance between scoring and earning. So the idea is that
you are playing a bowling game as the bowling pins. Your currency is related
to the actual bowling score, while your score is related to the number of pins
still standing.

Right now I think I have way too may ideas that are very nebulous. I think
that the best thing to do would actually be to just get started. Lol. But then
why is this procrastination stuff so much easier to do then?

We would also need to figure out how more pins would fall. If we want the game
to have any element of strategy, then we need to be able to communicate the
system via which the pins fall. Hell, even if we just want to implement the
damn thing, we need to have an idea of how it would fall.

So lets say that if a ball hits a shield, it stops immediately. So then the
only falling will be done by the pins...

So let a pin fall just in the direction that it was tipped from, so there
would potentially be any number of more pins in that direction, which would
work. Again this is all trending in a more thinky puzzly direction.

Lets go back to the theme and see if we can figure out something that has the
same aspect of scoring v losing. Or no. Lets stick on this. I think we can
still make it work.

So we need to have a system such that yeah I think it should work decently.
Basically think of the whole pyramid as a successive series of diagonals. So
the ball hits pin 1 and 2, which trigger their own diagonals, then, the ball
hits the remaining 3 pin pyramid at the exact same spot, and the same thing
continues.

Damn. I'm a little confused again.

---

09 Aug 2023:
Was travelling today. Just want to update to the newest zig version right now

though. I think that would be enough to do for today.

---

10 Aug 2023:
Okay, now we back. So lets make this happen. What is the thing to work on? I
think we need to get the scoring system working. Then the reset pins. Then the
effects. Lot of things there. But it will all build on top of one another.
Lets start off with the reset and scoring and frames and things like that.

There is a question here about whether we want ot contuinue on with that idea
we had of having the two separate scoring things. I still like the concept of
one of the effects being to spawn more pins. But whether we want that or not
is another thing.

I think for now it is better to go with it. We can possibly reverse the
functions. Let the standing pins be the currency, and the score be the score.

Aah, this is a little confusing overall for me because I am trying to get the
damn thing to work, and every struct I put in place seems to allow some sort
of powerup and that makes this all so hard. Okay. Start off with a standard
bowling scorecard, and let the rest happen later.

Whats the better way to do the ball position address stuff? I think I dont
like the bounciness of the ball. It should ideally just move straight, and
knock down the pins as it moves. So I think we should just have a x id for the
ball, and then let it move down on each thing.

NEXT: Get the scorecard updated and working.

Cool thats done. Now we have to figure out how we want to apply the effects
and things. Do we want to apply directly on the pins?
Actually there are some that might be better to put on the pins directly (like
shield) and for others?
No but the thing is that if we have an effect like can only be knocked over by
pin, then we would have to store that somewhere else. Maybe its best to have
all effects be externally stored.

Okay, we have the basic shield working. There are a lot of other things that
would need to be implemented ofcourse, but for now, we need to figure out some
workflow stuff as well.

---

14 Aug 2023:
Missed a day or two there. But thats okay. Lets make this all happen here
today and this week. It's all good sam

So what should we be doing now? I think the correct answer is to step back and
analyse and see. But that sounds scary and is more likely to result in things
not going our way. So then what is the best thing to do?

Lets get the scoring working. And then the full frame reset.

I like the idea of having a scorecard with 3 bowlers. And the final score is
all three of their scores combined or something like that. And then even the
store or whatever can come between the frames, rather than at any other
time...

And each of the bowlers will have a different way to get currency. Actually I
think it is a good idea, but it's a bit richer than I'd like.

So lets simplify. Before every frame, you get to optionally buy  1 gamelong effect, and
select 3 framelong effects. Those effects can either be played immediately or
hung onto.

Calm down sam. You're getting very scared and overwhelmed. That's okay. Take a
few deep breaths. This is all just a game. Allow the emotions to pass through
you, and just remember that none of this is particularly important in the
grander schemes.

So we need to create all the ideas for the things. First lets get the
scoreboard display implemented.

Okay, the scroecard stuff is done. Now we need the list of abilities and
stuffs. Lets implement one, where on the second shot, we have a 2x score
multiplier. So there is now the question how to store and calculate that
one...

---

15 Aug 2023:
Okay, we need to start off with adding the frame effects UI stuffs. Let's go.
So how do we want to do? I think before every frame, we need to pop up a box
or whatever, and then you click on the ones that you want. So lets have some
kind of radio button kinda things? Cool.

The basic interface is now set up. Next we would need to figure out how to add
the effects into the scoring system. I think that we should have the effects
listed in each frame and in the game. Okay. Basic stuffs set up.

Okay, so lets try to get some more stuff up now. What else is there? I don't
think we can get everything working, and then get to content, I think it just
has to go hand in hand. So lets do that.

Things to add: adding frames mid game?

---

16 Aug 2023:
I think I tdid the thing. So now we have to figure out the next thing that we
shoudl be doing. Okay. I think we should add quests, and more pins.

---

21 Aug 2023:
Cool, its another new week and another new project. This time we have the idea
of some kind of cellular automata ruleset. Basically, the concept is that you
will define the rules that the pixels will follow, and based on that, you will
have to accomplish certain goals. I don't know what the goals will be at this
point. I have no idra even whjat kind of goals make sense for an experience
like this. But I still think that the idea has merit. 

I think even just the programming and UI side of things will be relevant here.
So yeah. In terms of getting startd, I am not sure, but IU think we can start
off with the basic rulest, and then get that working. Hopefully it would lead
to some ideas for mechanics and things.

I like the elemental idea also. so if what we are controlling is fire, then
water or sand can be used to "extinguish" it. Or something along those lines.

Okay, lets get the basic stuffs that we want up and running ?

---

22 Aug 2023:
I don't know what the best thing to start off with today woukd be. We could
either make the targets. Actually, lets do the things we are sure will be
there. Targets, editable zones. Lets start off with editable zones.

---

24 Aug 2023:
It feels like a lot of the work that we  are diong is all in service of
avoidding the actual hard work of sitting andd doing design related things. So
I guess that means it is now time to sit and do the design related things.
But its scary. And thats why we should do it.

So I think there is also some kind of concern that the things that I think we
need to implement are hard.

But okay, lets make it simpler. Lets implment that turning level. Or maybe we
should do the target stuff? We also need to choose a theme sooner rather than
later.

Types of levels - goals. 
1. full level. Like the bridge.
2. Small section - like the bolt.

Okay we have the goal for today. Create the full level flow.
[x] level saving
[x] level loading
[x] level completion
[x] level editing - 
    [x] rules num, sizes. 
    [x] initial setup, 
    [x] target size, location etc.
    [x] zones num, size, location

---

25 Aug 2023:
Very bad. I didn't completing the things last evening. Lets do now. loading,
here we come. Also focus on getting it done. Yesterday we focussed a bit much
on elegance and all. Not required. Just get it working.

---

28 Aug 2023:
Cool. We have all the things set up and in place. We get to do one whole week
of level design. That sounds only pretty tiring but we got this =)

[x] Add play pause button / make sim stop once its looping
[x] change clear board to reset board.
[x] Click and drag to toggle multiple cells
[x] Permanent cells - already on board. cannot be removed. can be used in
    condition of rule - result will automatically match.
[x] Multiple target zones?
[x] Rules with fixed conditions.
[x] Rules only affect the first instance of the condition.

NEXT: Get fixed condition + result stuff working.

---

29 Aug 2023:
Lets move in all the points from yesterday that were not completed.
[ ] button to clear rule?
[ ] rules that rotate?
[ ] mirrored boards?
[ ] Cordon off some cells in the board (same color as off board)
[ ] Add support for rules to detect blank cells (off board) ?
[ ] Mechanically, cells that can only be edited after set time. If before
    that, you lose.

And now, start off with level design. =*
Do we have any ideas that we would like to try out?

---

15 Sep 2023:
Working on the byog jam.

Trying to figure out the first prototype that we want to have. So we should
probably have players and cards, and then play out the effects.

So we should have a target that the ball needs to reach to along with a
player. That's the level solution.
