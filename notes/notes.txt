23 Jun 2023:
Today is the first day of the project. Mostly it will end up setting up a
bunch of things. I don't really have much of an engine in place, so I think
the main focus for the day would be to set that up.

So I want to have the following things, all running in browser.
- Draw textured triangles (this will cover fonts as well) across user defined
  layers.
- Recieve mouse and keyboard inputs.
- Load files, and write to html5memory.
- Play sounds.

I have done some of these things before, with the KCPS port, but this time I
want it to be a little cleaner. I think instead of using webgl, I would like
to use web canvas, and see how that works. I don't know how well that would
deal with textured triangles and things, but it might be the simplest way to
get things started.

So going through the Canvas API, it seems that it has some pretty good support
for shapes and things, which we should take full advantage of. Eventually we
might want to target other platforms as well, but that is all a problem for
later. For now, we should just focus on making the best / simplest API across
zig and WASM.

I also want to keep some of the things that we learned from dragonruby. We
always want the final canvas to be of 1280x720. If the screen is larger or
smaller, let the renderer handle the scaling and things. For the sake of the
engine itself, it always considers that resolution, and so it can use that in
all the cases where it is necessary.

Step 1:
Set up a basic app, where we are drawing a square to the canvas. When space is
held down, the square changes to one colour. When mouse is held down, it
changes to another color. That's all. And also set up the build and things to
make it easy to run.

I think the focus should be on just working on this project for now. Forget
about the engine overall. We can slowly factor out the things that need to be
common. For now we should be fine just as is.

I am having some problems with WASM. When I import the wasm file, it doesn't
seem to have the functions that were exported from zig. This needs to be
fixed.

It seems like it was some issue with the build options, which has been changed
since all the public examples were posted...

---

The supported behaviour for inputs in web is that they pass a string with the
name of the key. That's not ideal to pass back into zig. So we probably should
be convert to a number in js itself? But it will be important to make sure
that the two are kept in sync.

---

Cool, now we have all the basic things passing through easily. That initial
POC stuff is done. I think we can stop here for today.
The next thing to work on would be to figure out where the game code goes, and
how much should go into main. Ideally, it should be as low as possible, but I
guess that's not fully in our hands. But lets try =).

---

26 Jun 2023:
So this week we have some work to get done on the jam. Some other time
commitments also. So let's just see how it all turns out. I think that we can
either start off on the game, or do some more amount of organisation. Though
actually I think those both are the same.

So lets just start off and see where it takes us I guess.
Okay, it seems like we now have the basic scaffolding mostly set up. So now
its just time to start implementing the rest of the things.

So lets draw the target wave first. Let it be a sine wave.

Okay, we have the basic of that thing rendering. Lets commit before we
proceed.

I am interested in trying out a breadboard based design for the wiring up of
the circuit. I think that might be cool. Then we can pick and place components
onto that, and it will do the things. But I think that comes a little bit
later. There is a lot more work that we need to get done with before we can
reach that stage.

The main thing that we need to figure out is how to pass around the data. In
my head it feels like that it is similar to a node-based programming system
like a blender or whatever. So that would probably be the structure as well?

What we want is to support each component having multiple outputs, and a fixed
set of inputs (like min will have to have atleast 2 inputs to even make
sense). I wonder whether that would make the breadboard idea better or
worse...
Also maybe breadboard doesn't make too much sense, because it becomes very
easy to short-circuit I think.

Okay, lets forget all of that for now. We have a much bigger question that
still needs to be answered. How exactly wre we going to be doing the
calculations. Maybe we just take one value, and then pass it down the whole
chain, and come out with another value at the other end. But there will be
branches and guys will have to wait for other branches to complete and things
like that. But we can just do basic depth-first or breadth first, either way
should be fine. Basically keep iterating through all the components until all
of them have been solved.

What is an easy way that we can test this all out though? Especially if we
want something like a frequency modulator? Lets start out with a basic set of
components.

- Source
- ~Double Frequency~ Source with 2x frequency.
- Half Amplitude
- Min

For example, if someone decides to put a frequency modulator at a later stage,
then I don't even know what the best way of thinking of that would even be.
Because at that point, we are trying to literally look forward/backward in
time. So maybe frequency modulation should not be allowed.

Yeah okay. I think that makes some modicum of sense. Maybe we can also just
allow rightwards connections? That also should be a decent thing.

Damn. Its a little complicated to figure out the smallest part of this to
build. But yeah, that's now pushed to tomorrow. Decent progress overall I
guess.

---

27 Jun 2023:
Bit late start to the day today. But lets see what we can accomplish =)
I think we need to just get some basic things up and working even if it does
not have in game interactivity.
Okay, now we need tofigure out exactly how the information will be travelling
thorugh the "wires".

Nice. We have a basic version running, and it looks good. Quite simple to code
out overall, though ofcourse, setting up the things in code obviously makes it
all a bit easier.
