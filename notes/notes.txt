23 Jun 2023:
Today is the first day of the project. Mostly it will end up setting up a
bunch of things. I don't really have much of an engine in place, so I think
the main focus for the day would be to set that up.

So I want to have the following things, all running in browser.
- Draw textured triangles (this will cover fonts as well) across user defined
  layers.
- Recieve mouse and keyboard inputs.
- Load files, and write to html5memory.
- Play sounds.

I have done some of these things before, with the KCPS port, but this time I
want it to be a little cleaner. I think instead of using webgl, I would like
to use web canvas, and see how that works. I don't know how well that would
deal with textured triangles and things, but it might be the simplest way to
get things started.

So going through the Canvas API, it seems that it has some pretty good support
for shapes and things, which we should take full advantage of. Eventually we
might want to target other platforms as well, but that is all a problem for
later. For now, we should just focus on making the best / simplest API across
zig and WASM.

I also want to keep some of the things that we learned from dragonruby. We
always want the final canvas to be of 1280x720. If the screen is larger or
smaller, let the renderer handle the scaling and things. For the sake of the
engine itself, it always considers that resolution, and so it can use that in
all the cases where it is necessary.

Step 1:
Set up a basic app, where we are drawing a square to the canvas. When space is
held down, the square changes to one colour. When mouse is held down, it
changes to another color. That's all. And also set up the build and things to
make it easy to run.

I think the focus should be on just working on this project for now. Forget
about the engine overall. We can slowly factor out the things that need to be
common. For now we should be fine just as is.

I am having some problems with WASM. When I import the wasm file, it doesn't
seem to have the functions that were exported from zig. This needs to be
fixed.

It seems like it was some issue with the build options, which has been changed
since all the public examples were posted...

---

The supported behaviour for inputs in web is that they pass a string with the
name of the key. That's not ideal to pass back into zig. So we probably should
be convert to a number in js itself? But it will be important to make sure
that the two are kept in sync.

---

Cool, now we have all the basic things passing through easily. That initial
POC stuff is done. I think we can stop here for today.
The next thing to work on would be to figure out where the game code goes, and
how much should go into main. Ideally, it should be as low as possible, but I
guess that's not fully in our hands. But lets try =).

---

26 Jun 2023:
So this week we have some work to get done on the jam. Some other time
commitments also. So let's just see how it all turns out. I think that we can
either start off on the game, or do some more amount of organisation. Though
actually I think those both are the same.

So lets just start off and see where it takes us I guess.
Okay, it seems like we now have the basic scaffolding mostly set up. So now
its just time to start implementing the rest of the things.

So lets draw the target wave first. Let it be a sine wave.

Okay, we have the basic of that thing rendering. Lets commit before we
proceed.

I am interested in trying out a breadboard based design for the wiring up of
the circuit. I think that might be cool. Then we can pick and place components
onto that, and it will do the things. But I think that comes a little bit
later. There is a lot more work that we need to get done with before we can
reach that stage.

The main thing that we need to figure out is how to pass around the data. In
my head it feels like that it is similar to a node-based programming system
like a blender or whatever. So that would probably be the structure as well?

What we want is to support each component having multiple outputs, and a fixed
set of inputs (like min will have to have atleast 2 inputs to even make
sense). I wonder whether that would make the breadboard idea better or
worse...
Also maybe breadboard doesn't make too much sense, because it becomes very
easy to short-circuit I think.

Okay, lets forget all of that for now. We have a much bigger question that
still needs to be answered. How exactly wre we going to be doing the
calculations. Maybe we just take one value, and then pass it down the whole
chain, and come out with another value at the other end. But there will be
branches and guys will have to wait for other branches to complete and things
like that. But we can just do basic depth-first or breadth first, either way
should be fine. Basically keep iterating through all the components until all
of them have been solved.

What is an easy way that we can test this all out though? Especially if we
want something like a frequency modulator? Lets start out with a basic set of
components.

- Source
- ~Double Frequency~ Source with 2x frequency.
- Half Amplitude
- Min

For example, if someone decides to put a frequency modulator at a later stage,
then I don't even know what the best way of thinking of that would even be.
Because at that point, we are trying to literally look forward/backward in
time. So maybe frequency modulation should not be allowed.

Yeah okay. I think that makes some modicum of sense. Maybe we can also just
allow rightwards connections? That also should be a decent thing.

Damn. Its a little complicated to figure out the smallest part of this to
build. But yeah, that's now pushed to tomorrow. Decent progress overall I
guess.

---

27 Jun 2023:
Bit late start to the day today. But lets see what we can accomplish =)
I think we need to just get some basic things up and working even if it does
not have in game interactivity.
Okay, now we need tofigure out exactly how the information will be travelling
thorugh the "wires".

Nice. We have a basic version running, and it looks good. Quite simple to code
out overall, though ofcourse, setting up the things in code obviously makes it
all a bit easier.

---

28 Jun 2023:
We got the basic things up. Now we need to add some kind of interface that we
can interact with. Okay then.
We also need to figure out exactly what is the interface that we want to build
for the thing.
Also game name idea: sine cosine desine

Back to the interface though for now. We had some ideas I think. The main
thing that we need to accomplish is to make sure that there is nothing that is
being connected backwards.

That was quite a bit that we got done today.
I think tomorrow we have to clean up creating and deleting connections. We
were concerned that there was no way to delete a connection on an undeletable
component, but there is no reason why a right click couldn't just remove all
its connections...


---

29 Jun 2023:
Okay what is the first thing that awe can work on today? It's either
converting the connections to the component tree. Or some more controls.

---

30 Jun 2023:
So we have the _toy_ ready. Today we need to make it into a game.

---

10 Jul 2023:
Working on hiveminder. We have the basic hex grid ready. Now we have to ask
the question, what is the experience of a city builder that we are looking to
distill? What is it about the genre that we think should be captured. Forget
all the other things that you know a bout games right now. Just focus on that
base.

Growth is definitely one. The feeling of accomplishment over watching the
thing grow.
Balance of resources. You need population to fill jobs. But houses require
maintenance. More houses means that a large part of the new population will go
towards maintenance rather than industry.

What are the decisions that you take? And what are the decisions that are out
of your hands?
- What to build where. In the case of a beehive, the plots are all already
  fixed. All you just decide what needs to be built.

What are the resources that we are balancing?
- Population
- Food
- Jobs

What are the jobs?
- Food / honey collection
- Builders
- Looking after youngers

What are the rooms?
- Queen
- Queen minders / look after youngers
- Food Collectors
- Builders
- Maintainers
- Storage
- Sleep
- Incubate

What are the other mechanics
- Frustration - if bees are working too much, their frustration will rise so
  you need to have enough bees in all the workstations
  If there is too much frustration, then the bees will revolt (and for now,
  you lose)
- Hunger - If there isn't enough honey, bees will eventually die

I think that's enough to get started? I mean, it's honestly too much to get
started, but we still, at some point do need to get started.

What's the first step, what do we need to build first? Damn, that's hard to
figure.

So let's start off with having a simulated working hive. One queen at the
center, one of each room around. And then figure out. Okay. Okay. Okay.

Where do the bees sleep?

Okay, so the way that each bee works:
- request job
- if available: perform job for JOB_LENGTH time
- request food (consume if available)
- request rest (

The way jobs work:
Each job requires a room. That room has a fixed number of slots. When a bee
requests job, if any jobroom has on opening, the bee will get assigned to that
job. Based on the job, some stats of the hive will be modified.

Food:
Every FOOD_DISTRIB cycle, food is equally distributed amongst all bees up to
MAX_FOOD per bee. So if there is not enough total food, each bee will get
equal amount. (Will this lead to a mass death at one point?)
Or we will give MIN_FOOD to each bee based on need until food runs out.

Rest:
If there is a job to be done, bees will do it. If there is none, they will
rest.
(How to balance this so that overworked bees are not at the head of the queue
for jobs?)

So doing a job leads to bee.rest-- and resting leads to bee.rest++
Over time, bee.health--. When they eat, bee.health++
